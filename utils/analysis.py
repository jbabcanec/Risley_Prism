import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle

def analyze_scan_pattern(Laser_coords, save_plots=True):
    """
    Analyze the scan pattern generated by the Risley prism system.
    
    Parameters:
    -----------
    Laser_coords : dict
        Dictionary containing laser coordinates for each time step
    save_plots : bool
        Whether to save analysis plots to file
    
    Returns:
    --------
    dict
        Analysis results including scan area, beam diameter, etc.
    """
    
    # Extract final positions (at workpiece)
    final_positions = []
    for key, coords in Laser_coords.items():
        if coords:  # Make sure coords is not empty
            final_pos = coords[-1]  # Last position (at workpiece)
            final_positions.append([final_pos[0], final_pos[1]])  # x, y only
    
    final_positions = np.array(final_positions)
    
    if len(final_positions) == 0:
        return {"error": "No valid coordinates found"}
    
    # Calculate scan pattern statistics
    x_coords = final_positions[:, 0]
    y_coords = final_positions[:, 1]
    
    # Scan area statistics
    x_range = np.max(x_coords) - np.min(x_coords)
    y_range = np.max(y_coords) - np.min(y_coords)
    scan_area = x_range * y_range
    
    # Center of scan pattern
    center_x = np.mean(x_coords)
    center_y = np.mean(y_coords)
    
    # Calculate effective beam diameter (95% of points)
    distances = np.sqrt((x_coords - center_x)**2 + (y_coords - center_y)**2)
    effective_diameter = 2 * np.percentile(distances, 95)
    
    # Create analysis plots
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle('Risley Prism Scan Pattern Analysis', fontsize=16, weight='bold')
    
    # Plot 1: 2D scan pattern
    ax1.scatter(x_coords, y_coords, c=range(len(x_coords)), cmap='viridis', 
               s=20, alpha=0.7)
    ax1.set_xlabel('X Position')
    ax1.set_ylabel('Y Position')
    ax1.set_title('Scan Pattern at Workpiece')
    ax1.grid(True, alpha=0.3)
    ax1.axis('equal')
    
    # Add circle showing effective beam diameter
    circle = Circle((center_x, center_y), effective_diameter/2, 
                   fill=False, color='red', linestyle='--', linewidth=2)
    ax1.add_patch(circle)
    ax1.plot(center_x, center_y, 'r+', markersize=10, markeredgewidth=2)
    
    # Plot 2: Temporal progression
    ax2.plot(range(len(x_coords)), x_coords, 'b-', label='X position', alpha=0.7)
    ax2.plot(range(len(y_coords)), y_coords, 'r-', label='Y position', alpha=0.7)
    ax2.set_xlabel('Time Step')
    ax2.set_ylabel('Position')
    ax2.set_title('Position vs Time')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # Plot 3: Distance from center vs time
    ax3.plot(range(len(distances)), distances, 'g-', linewidth=2)
    ax3.axhline(y=effective_diameter/2, color='r', linestyle='--', 
               label=f'95% containment: {effective_diameter/2:.2f}')
    ax3.set_xlabel('Time Step')
    ax3.set_ylabel('Distance from Center')
    ax3.set_title('Beam Displacement from Center')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # Plot 4: Histogram of distances
    ax4.hist(distances, bins=20, alpha=0.7, color='skyblue', edgecolor='black')
    ax4.axvline(x=effective_diameter/2, color='r', linestyle='--', linewidth=2,
               label=f'95% radius: {effective_diameter/2:.2f}')
    ax4.set_xlabel('Distance from Center')
    ax4.set_ylabel('Frequency')
    ax4.set_title('Distribution of Beam Positions')
    ax4.legend()
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_plots:
        plt.savefig('output/scan_pattern_analysis.png', dpi=300, bbox_inches='tight')
        print("Scan pattern analysis saved to output/scan_pattern_analysis.png")
    
    plt.show()
    
    # Compile results
    results = {
        'scan_area': scan_area,
        'x_range': x_range,
        'y_range': y_range,
        'center_position': (center_x, center_y),
        'effective_diameter': effective_diameter,
        'max_displacement': np.max(distances),
        'mean_displacement': np.mean(distances),
        'std_displacement': np.std(distances),
        'num_positions': len(final_positions)
    }
    
    # Print summary
    print("\n" + "="*50)
    print("SCAN PATTERN ANALYSIS SUMMARY")
    print("="*50)
    print(f"Total scan area: {scan_area:.2f} square units")
    print(f"X range: {x_range:.2f} units")
    print(f"Y range: {y_range:.2f} units")
    print(f"Center position: ({center_x:.2f}, {center_y:.2f})")
    print(f"Effective beam diameter (95%): {effective_diameter:.2f} units")
    print(f"Maximum displacement: {np.max(distances):.2f} units")
    print(f"Mean displacement: {np.mean(distances):.2f} units")
    print(f"Number of scan positions: {len(final_positions)}")
    print("="*50)
    
    return results

def calculate_scan_efficiency(Laser_coords):
    """Calculate scanning efficiency metrics."""
    
    final_positions = []
    for key, coords in Laser_coords.items():
        if coords:
            final_pos = coords[-1]
            final_positions.append([final_pos[0], final_pos[1]])
    
    if len(final_positions) < 2:
        return {"error": "Insufficient data for efficiency calculation"}
    
    final_positions = np.array(final_positions)
    
    # Calculate path length
    total_path_length = 0
    for i in range(1, len(final_positions)):
        dx = final_positions[i][0] - final_positions[i-1][0]
        dy = final_positions[i][1] - final_positions[i-1][1]
        total_path_length += np.sqrt(dx**2 + dy**2)
    
    # Calculate scan area covered
    x_range = np.max(final_positions[:, 0]) - np.min(final_positions[:, 0])
    y_range = np.max(final_positions[:, 1]) - np.min(final_positions[:, 1])
    scan_area = x_range * y_range
    
    # Efficiency = area / path length (higher is better)
    efficiency = scan_area / total_path_length if total_path_length > 0 else 0
    
    return {
        'total_path_length': total_path_length,
        'scan_area': scan_area,
        'efficiency_ratio': efficiency,
        'points_per_unit_area': len(final_positions) / scan_area if scan_area > 0 else 0
    }